const notionData = `#separator:tab
#html:true
#tags column:4
<i>Why does <code>Constructor.prototype</code> NOT EQUAL <code>Constructor.__proto__</code>?</i>	The prototype property on <code>Constructor</code> points at the object from which <code>Constructor</code>'s instances inherit.&nbsp; Put differently: <code>Constructor.prototype</code> points at the prototype&nbsp;<i>of all its instances.<br></i><br>The value returned by invoking the <code>__proto__</code> getter on <code>Constructor</code> accesses Constructor's special internal <code>[[Prototype]]</code> of which Constructor itself (as a function object) is an instance.&nbsp; Thus <code>Constructor.__proto__ === Function.prototype</code> returns true since all&nbsp;<i>most&nbsp;</i>functions are <code>instanceof Function</code>.		constructors function_prototype inheritance object_prototype
What are some trade-offs to consider when choosing the factory function pattern of object creation?	"factory functions are great in that they're a really simply, straightforward, ""low-tech"" OO solution when we need multiply instances of an object.  We achieve one of the main benefits of OO (eg. grouping related behavior and data together).  They rely on ordinary function invocation and a plain object being returned.&nbsp; They harness the powers of closure while being easy to implement and understand at a glance. <br><br>The trade-off of simplicity vs. redundancy.&nbsp; If you create a bunch of objects with various properties that are methods, those function objects are&nbsp;<i>duplicated</i>&nbsp;for&nbsp;<b>each&nbsp;</b>individual object.&nbsp; So if we have 1 million objects, each with 1 million methods, then we have a lot of duplicate code which could stretch system resources (?).&nbsp; Assuming we're returning plain objects that inherit directly from <code>Object.prototype</code>, each object <i>owns</i> its functionality.&nbsp; Additionally, plain objects returned by a factory function lack a ""type"", which can make debugging and thinking about code more challenging for a user of those objects since those objects lack specificity of type."		closure object_creation_pattern object_factories
Suppose we have two constructor functions <code>A &amp;&amp; B</code>.&nbsp; We use <code>A</code> to create a pretty useful object <code>a</code> that has access to all the data and behaviors present in the object referenced by: { <code>A.prototype</code> }. However, the instances of <code>A</code> have some additional behavior we'd like our newly-created <code>a</code> object to be able to use.&nbsp; How might we facilitate the described behavior sharing?	Since Javascript objects can inherit&nbsp;<i>directly</i>&nbsp;from a single<b>&nbsp;</b>prototype object, that object's <i>object prototype</i>: { <code>A.prototype</code> } needs the object: { <code>B.prototype</code> } somewhere upstream on its prototypal chain.  This would grant instances of <code>A</code>&nbsp;access to the behaviors available to instances of&nbsp;<code>B</code>.		constructors delegation inheritance prototype_chain
"How can we say that “functions are also objects” when the expression <span style=""background-color: rgba(135, 131, 120, 0.15); color: rgb(235, 87, 87);"">typeof someFunction</span> returns&nbsp;<span style=""background-color: rgba(135, 131, 120, 0.15); color: rgb(235, 87, 87);"">""function""</span>?"	The <code>Function</code> constructor is an <code>instanceof</code> the <code>Object</code> constructor. The <code>Object</code> constructor is an  <code>instanceof</code> the <code>Function</code> constructor, thus it would be true to say that some objects are functions, but all functions are objects since all JS functions are first class in nature. A function is a special type of object that responds to: <code>call apply bind</code>.		constructors first_class_citizen inheritance
What does a <code>Constructor</code>'s prototype property return?	<code>Constructor.prototype points at the object&nbsp;</code>that will become the <code>[[Prototype]]</code> of <code>Constructor's</code> instances.&nbsp; This object is also the&nbsp;<code>[[Prototype]]</code> of the <code>Constructor</code>'s execution context!<br><br>When a non-arrow function is defined, it is automatically given the <code>prototype&nbsp;</code>prop which references an object whose <code>[[Prototype]]</code> is <code>Object.prototype</code> or the top-level object.		constructors execution_context function_prototype inheritance
What's one strategy to link the instances of two different <code>Constructor</code>s?	We can manually set the <code>prototype</code> property of <code>A</code> to point at a <code>{}</code> which inherits from <code>B.prototype</code> like this: <code>A.prototype = Object.create(B.prototype);</code>.		object_prototype OLOO prototype_object
If we cannot use the <code>class</code> syntactic sugar abstraction's <code>super</code> keyword to facilitate delegation, how might we implement <code>super</code>'s functionality within the pseudo-classical approach?	Theoretically, we could utilize <code>Function.prototype.apply</code> or <code>Function.prototype.call</code> within the <code>Constructor</code> function and pass the current context <code>this</code>.<br><br>This might look like: <code>Constructor.prototype.desiredBehavior.call(this)</code>.&nbsp;<br><br>Basically: directly reference the desired constructor function OR access that constructor's function prototype which has the desired <code>constructor</code> property and pass along the current execution context and any additional args using <code>call apply</code>.		delegation execution_context pseudo-classical this
What is the dunder <code>__proto__</code>?	A special internal property on all objects that holds a reference to another object, the holder's direct prototype.		__proto__vs_.prototype inheritance object_prototype
"consider the code below:<br><code>bar.isPrototypeOf(foo); // returns true</code><br>
<code>Object.getPrototypeOf(foo) === bar; // returns false</code>.<br> How is this scenario possible?"	"It's possible because <code>Object.prototype.isPrototypeOf(obj)</code> searches <code>obj</code>'s prototype chain to see if its <code>receiver</code> (in this scenario <code>bar</code>) is upstream of <code>foo</code>.
<br><br>
This behavior is in contrast to the <code>Object.getPrototypeOf(foo)</code> method which will return the value of <code>foo</code>'s internal <code>[[Prototype]]</code>. This is the object from which <code>foo</code> <bold>directly</bold> inherits from, which it can only have one of. Thus, this code makes sense since there could be other objects (or ""links"") between <code>foo</code> and <code>bar</code> along <code>foo</code>'s prototype chain."		inheritance object_prototype prototype_chain
What are some considerations to make with code executing in Browser vs. code executing in Node?	"1. The implicit execution context is different in each runtime environment<br>2. JavaScript code executed in Node in a <code>.js</code> file is wrapped in a function<br>3. There exists an addition scope above a .js file's ""global"" scope called ""module scope"".&nbsp; This layer accounts for the differences re: the global object between node and browser.<br>4. Some browsers don't&nbsp;<i>natively</i> support CommonJS modules since CommonJS was built for the <code>Node.js</code> environment, however tools like Babel allow transpiling of CommonJS modules for browser runtimes."		execution_context implicit modules runtime_environment
Given this function: <code>function a() { return this.name; }</code><br><br>What will <code>a.call(1);</code> return?	It will return <code>undefined</code>.<br><br>This feels jarring but importantly, demonstrates that a function can execute with a primitive value as its execution context. <b>Typically</b> the calling object or context of a function is an object (eg. <code>window</code> or <code>global</code> or some user-defined object).<br><br>It's likely beyond the scope of what I need at this point in the cirriculum, but under the hood, i'm fairly certain that what happens is JS recognizes that the value passed&nbsp;<code>call</code> is a primitive and automatically makes the value an object.	"<img src=""Screenshot 2023-10-03 at 9.43.14 PM.jpg"">"	execution_context indirect_invocation primitives
Mental Model of Method	"a method is a&nbsp;<code>Function</code> with a receiver (the object used to invoke the method).<br><br>inversely, a  call without an explicit receiver is a <code>Function</code>.<br><br><quote>Brandon Conway post: The ""function"" vs ""method"" classification actually relates to how the function is executed. If a receiver must be specified, it is a method. If no receiver needs to be specified, it is a function. These invocations are known as ""method invocation"" and ""function invocation"". That means the same function object can be both</quote>"		execution_context explicit implicit invocation_types
What is the value of&nbsp;<code>this</code> inside an IIFE executed without an explicit context object in browser?	<code>window</code>		execution_context explicit immediately_invoked_function_expression runtime_environment
What do we have to remember about&nbsp;<code>Function</code>s declared and invoked within a method body?&nbsp;&nbsp;	"This answer assumes the following: 1) we are using normal function invocation; no indirect invocation, constructor invocation, method invocation.&nbsp; And 2) the function inside the method is not defined using the arrow syntax.<br><br>inside a method <code>this</code>&nbsp;refers to the method's containing object (the method's implicit context).  We might assume that since the function is declared inside that method body, <code>this</code> will point to the method's receiver and propagate into all enclosing scopes and&nbsp;<code>Functions</code>.<br><br>This is incorrect.&nbsp;&nbsp;<code>this</code> in the function points at either <code>window</code> or <code>globalThis</code> or <code>undefined</code> depending on if the <code>""use strict""</code> directive has been set.<br><br>"		invocation_types this
What's a practical reason for why we need <code>this</code> when our programs grow in complexity?	say we have object literal with method props that reference the object literal by name (via some variable that references said object literal) and the variable name changes.&nbsp; This could cause serious problems down the line.&nbsp; Hence,&nbsp;<code>this</code> solves this specific issue as a general context reference.		first_class_citizen lookup scope this variable
True or False:&nbsp; The execution context of a function relates to the value of <code>this</code> where the function is <b>declared</b>.	FALSE*<br><br>The execution context of a function (defined via function declaration) is determined by&nbsp;<i>how&nbsp;</i>that function is <b>invoked</b>, not the current value of <code>this</code>&nbsp;where it was defined.&nbsp; If invoked&nbsp;via function invocation, that function receives its context <b><u>implicitly</u></b>&nbsp;<i>at time of execution&nbsp;</i>from Javascript.<br><br>*caveat: <code>this</code>'s value at the time of a function's <b>definition</b>&nbsp;and subsequent <b>invocation</b>&nbsp;<b>can</b>&nbsp;impact that function's context binding if that function were indirectly invoked or we're talking about an arrow function. However, this can make things more confusing.&nbsp;Otherwise, the original answer stands, though there is nuance here.		arrow_function execution_context this
General Mental Model re: variables and objects:<br><br><code>let a = {cool:true};</code><br><code>let b = a;</code><br><br>	Unlike with primitives, variables hold a <b>reference</b> to objects. On line 1 <code>a</code> holds the reference to the object <code>{cool: true}</code>.  On line 2, a reference identical to the one held by variable <code>a</code> is held by variable <code>b</code>.  This means that both variables reference the <b>same object</b>.		aliases mutability pass_by_reference primitives variable
"What's ""the point"" of inheritance from a design perspective? What are some benefits it facilitates for a developer?"	Using inheritance allows us to establish hierarchies in our code.&nbsp; We can place some general data and behavior in a class upstream and have more specialized data and behaviors placed in a downstream class.&nbsp; Organizing data and behavior in this manner mitigates code duplication making the responsibilities and purpose of different classes evident, which in turn reduces the cognitive load on the developer and allows them to focus on higher-level activity.&nbsp;&nbsp;<br><br>Inheritance also facilitates <i>polymorphism</i> since instances with differing <code>{ function prototypes }</code> but whose prototypes exist on the same prototypal chain can respond to the <b>same</b> 'message' (method invocation) in different ways. <br><ul><li>Modular (packed) code</li><li>reusability as opposed to redundancy</li><li>extensible and thus easier to maintain (what if we want to add some behavior to a class and ensure all previous and future instances of that class have that behavior?)</li><li>encapsulation</li></ul>		function_prototype inheritance object_prototype
What is object oriented programming?	a programming paradigm that uses the&nbsp;<code>Object</code> as the basic building block of an entire program. Fundamentally, it is about grouping data and behaviors into noun-like entities.&nbsp; It contrasts to only using variables and composing functions to build a program (functional programming).		OO
Is the data contained inside an object automatically private?	No. By default it is accessible via property accessor.		private_data
"True or false: ""Object factories become less valuable as the number of objects in a program increases."""	False.<br><br>The factory function object creation pattern is still a valuable, if low-tech, OO design approach. It depends on what we are trying to accomplish.  The main drawbacks to this approach are code redundancy, an inability to make use of a prototype chain which would be provided by default via the pseudo-classical approach (assuming you're not combining this approach with OLOO), and limited extensibility.<br><br>But as far as facilitating data privacy and creating an interface with which to interact with that data, object factories are valuable.		object_factories private_data
What's a significant difference between how arrow functions and normal functions determine the value of&nbsp;<code>this</code>?	"Arrow functions inherit the execution context from the enclosing lexical environment where they are defined.<br><br>THIS DOES NOT MEAN ARROW FUNCTION'S DETERMINE THEIR SCOPE LEXICALLY!&nbsp;<span style=""color: rgb(255, 255, 255);""><a href=""https://launchschool.com/lessons/c9200ad2/assignments/f68a9f7f"">lexical_scope_discussion</a>&nbsp;&nbsp;</span><br><br>Rather, an arrow function's E.C. is determined by the <i>current</i> value of <code>this</code> at point of definition.&nbsp; This is different from normal functions; their E.C. is determined dynamically based upon <i>how they are invoked.&nbsp;</i><br><br>Scenario:<br><br>Suppose we have an object with a method (defined with normal function syntax) which defines and returns an arrow function.&nbsp; Say we invoke the object's method thus extracting the arrow function, which we promptly invoke.&nbsp; The returned function's execution context will forever be the receiver that&nbsp;the outer method which returned the arrow was invoked with.  This is true as the value of <code>this</code> within method's body resolved implicitly to the method's calling object itself, and since arrow functions inherit their EC based on the <i>current</i> value of <code>this</code> where they are <i>defined</i>, that context object is the <i>method's&nbsp;</i>receiver.<br><br>Normal functions determine their EC based on how they are invoked. Neither the scope at the time of the function's definition nor the function's invocation directly impacts that function's execution context. "		arrow_function execution_context invocation_types lexical_environment
Are property names and variables the&nbsp;<b>same thing?&nbsp; H</b>ow does this relate to the difference between scope and&nbsp;<code>this</code> within objects?	"Pete says, ""Don't confuse property names with variables!""<br><br>

In this code: <code>let obj = {name: name};</code> the two <code>name</code>s are entirely different entities.  The first is a property name on the object <code>obj</code> whereas the second is a local variable.  Thus, when JS executes the code, it first creates the object <code>obj</code>, then creates the property <code>name</code> (itself a string), and then searches for an in-scope variable called <code>name</code>.<br><br>
The distinction between variables and properties highlights how  objects themselves <b>DONT</b> create new scopes (although methods defined on objects <b>DO</b> create new scopes) and how you ""aren't relying on scope when you use <code>this</code>; that's the context which is a separate concept"""		lookup property scope variable
What other core programming language paradigm does JS support and how does this paradigm manifest itself in Javascript?	"Despite being an OO language, Javascript also supports the <i>functional programming paradigm</i> wherein programs are constructed by applying and composing functions.<br><br>This paradigm is evident in Javascript's support of&nbsp;<i>first class functions</i> which effectively means that functions are themselves values (since, within an expression, they resolve to&nbsp;<i>something,&nbsp;</i>think:&nbsp;<code>[1, 'string', true, {}, null, new Date()]</code>); or specifically: special objects. (what makes them ""special"" is that they respond to <code>call apply bind</code>)&nbsp;&nbsp;<br><br>As such, JS functions can be passed to other functions as arguments (H.O.F.), returned from other functions (H.O.F.), set as the value of an object property (methods), or be the value to which a variable's reference points."		first_class_citizen higher_order_function OO variable
What is the characteristic of Javascript functions that necessitates a strong understanding of function execution context?	Functions in JS are first-class and as such can be passed around and exist and execute within different contexts.&nbsp;&nbsp;So, if a function is invoked without being supplied an explicit context it has been bound, that function receives its execution context from JS at time of invocation, which will be the implicit execution context object (either&nbsp;<code>window || globalThis || undefined</code> ('use strict')).&nbsp; If a function is invoked using indirect invocation, then that function's execution context is the first argument passed to whichever&nbsp;<code>Function.prototype</code> method used to invoke our function.<br><br>All of this is significant as the execution context of a function determines the value of <code>this</code> within that function and, based on a number of factors, can be implicitly or explicitly set (received?).<br><br>Also it's to consider that the&nbsp;<i>same&nbsp;</i>function can be invoked and passed around and the value of&nbsp;<code>this</code> will depend upon how that function is invoked.		execution_context explicit first_class_citizen implicit invocation_types
"What is a ""global value""?&nbsp; Provide examples.&nbsp; Is a variable declared in the global scope considered a global value?"	"A global value is a value which exists as a property of the global object.&nbsp;&nbsp;<code>Infinity NaN parseInt</code> are all <i>global values</i>.<br><br>Functions declared in the global scope (or a function declared in a block scope within the global scope) and undeclared but initialized variables (IMPORTANT: both in the top level scope as well as within function bodies) will become ""global values"". However, things like variables declared with <code>let</code> or <code>const</code> are NOT global values since they're not properties on the global object.&nbsp; This also applies to functions declared inside of function scopes (even when invoked) are NOT global values since they're not on the global object!).&nbsp; Strict mode prevents an initialized undeclared variable from becoming a prop on the global object via a <code>Uncaught ReferenceError</code>"		global_object scope
What's some odd behavior when we use the global&nbsp;<code>isNan</code> function?	Both&nbsp;<code>isNan('not a number')</code> and <code>window.isNan('not a number')</code> will erroneously return <code>true</code> as a result of both coercing the string <code>not a number</code> to <code>NaN</code>.  This is why we use the static method: <code>Number.isNan</code>.		error global_object
What's the subtle but significant difference that applies to a variable declared and initialized in the global scope and an undeclared variable initialized in either the global scope or any scopes the global encloses?	"(this answer assumes we are in the browser environment without the <code>""use strict""</code> directive)<br><br>Both will become properties of the global object but the one declared and initialized with <code>var</code> in the global scope <b>cannot be deleted</b> from the global object, whereas the property which came to be via the undeclared but initialized variable <b>can</b> be removed from the global object using <code>delete</code>."		error global_object runtime_environment strict_mode_code
What's a difference between Node and browser environments with regard to scope and their respective implicit execution contexts?	Browser's&nbsp;global object is <code>window</code> whereas Node's is <code>global || globalThis</code>.<br><br>Node has an additional <i>module scope</i> at the top level which distinguishes it from browser javascript. The consequence of this is that global variables declared at the top level in a node file are <i>NOT</i> properties of <code>global</code> and as such are only accessible from within the file.<br><br>The causal mechanism that accounts for this behavior is the wrapper function Node files are executed in. Due to this wrapper, the value of <code>this</code> within the global scope of a node file's code is a an empty object <code>{}</code>.&nbsp; It also means that global definitions have&nbsp;<i>function scope</i>.		execution_context runtime_environment scope
"List synonymous phrases to ""<i>execution context""</i>"	"""the function receiver"", ""the context object"", <code>this</code> (the keyword that makes the execution context available), ""the executing object""<br>""the value of the context keyword <code>this</code>""<br><br>I currently dislike using the term ""receiver"" in relation to a function invocation as ""receiver"" feels far more <u>connected</u> to method invocation."		constructor_invocation execution_context explicit implicit method_invocation this
What are the two types of execution contexts?	Implicit (determined by javascript) and Explicit (determined by developer)		execution_context
What's a common misconception that leads to developers often struggling to understand Javascript context binding?	"that Javascript&nbsp;<b>DOES NOT&nbsp;</b>use&nbsp;<i>lexical scoping rules&nbsp;</i>to determine a context binding and that the rules which govern&nbsp;<code>this</code> are distinct from the rules that govern variable scope.*&nbsp; <br><br>A lot of this confusion arise from the use of overloaded terms like ""lexical"", ""static"", and ""dynamic""; all of which are used when describing the rules of scope and context bindings.<br><br>*there's further nuance to this statement when we consider how arrow functions receive their EC.&nbsp;&nbsp;Arrow functions do not create their own context bindings.&nbsp; Instead, they inherit an E.C. based on the current value of <code>this</code> in the enclosing lexical environment where the arrow function is defined. Importantly here, ""current"" is meant to convey that the<b>&nbsp;state</b> of the code at the time of the arrow function's <i>definition</i> relies upon that code being executed."		common_misconception execution_context lexical_scoping_rules scope
"True or False: <i>""binding a function to a context object occurs when you define the function, not when you execute it.""</i>"	False.&nbsp; &nbsp;&nbsp;<br><br>It's the opposite. However, if we are talking about <i>hard&nbsp;binding</i> a function using <code>bind</code> then the answer would be True.<br><br>Also, if we are considering an arrow function's context binding, the answer changes as the EC of arrow functions depends&nbsp;upon the value of <code>this</code> in the enclosing lexical environment where they were defined and that environment's execution state.  Thus, it can be said that determining a function's context binding, we must consider a number of factors.		execution_context lexical_environment
We refer to the execution context of a method invoked without an explicit execution context provided as the:	"implicit&nbsp;<i>method</i>&nbsp;execution context<br><br>further commentary:<br><br>This phrasing initially bothered me since, at least visually, we (the dev) write the code:&nbsp;<code>object.method()</code> which <i>feels</i>&nbsp;pretty&nbsp;<b>explicit</b>. The distinction between: ""implicit function execution context"" &amp; ""implicit method execution context"" is moot as the Javascript engine sets the execution context for each in both scenarios. <br><br>For the <b>method</b>, the calling object is used to invoke the function and JS looks for the method on the calling object and if it doesn't find it, searches the rest of that object's prototype chain until it resolves the property lookup or comes up empty.<br><br>For the&nbsp;<b>function,&nbsp;</b>if the function is invoked via function invocation, then the function receives its execution context at the time of its invocation and is the global object.<br><br>Thus, while it's true that a method being invoked using some object of which that method might be a member to&nbsp;<i>feels&nbsp;</i>explicit, it is <b>not an example of explicit method execution (</b>which AFAIK isn't possible).<br><br>we also cannot make the assumption that the object being used to invoke some method even contains that method.  Perhaps the method is defined upstream of the calling object and thus the receiver is <i>delegating</i>&nbsp;the method to a different upstream object.  While the value of <code>this</code> will be object used to invoke the method, that receiver doesn't contain the method."		delegation execution_context implicit inheritance prototype_chain
What's the most important rule to remember about the execution context of functions?	When we invoke either a function or a method, the execution context is determined by&nbsp;<i>HOW&nbsp;</i>you invoke that function/method.<br><br>it's a good rule, but remember that it doesn't universally apply: functions invoked via constructor invocation and arrow functions have different rules which govern their execution contexts.&nbsp; In the case of constructor invocation, the execution context of that constructor is the value referenced by <code>this</code> within that constructor which is <i>likely</i> the constructor's return value.&nbsp; In the case of the arrow function, its E.C. is the enclosing scope's execution context; the value of&nbsp;<code>this</code>&nbsp;where the arrow function was defined.		arrow_function constructors execution_context invocation_types
What's a common problem once a&nbsp;<code>Function</code>&nbsp;has been extracted from the object where it was a method via property accessor: <code>object.methodName </code>?	Context loss.&nbsp; Once extracted/removed, the&nbsp;<code>Function</code> loses its original context.&nbsp; Depending upon the nature of the extracted function's invocation, it is likely that the value of &nbsp;<code>this</code> is the wrong context object.		context_loss execution_context first_class_citizen invocation_types
Scenario: a function is removed from its containing object.<br><br> What's a strategy we can use to address context loss triggered via a variable which held a reference to the containing object going out of scope?	One partial solution could be to provide an extra <code>context</code> parameter at the time when the <code>Function</code> object is passed to, say another function as an argument.  This approach lets us create an alias for the original context object that we can use to specify an explicit execution context upon invocation using&nbsp;<code>Function.prototype.call || Function.prototype.apply</code>.&nbsp;<br><br>However, if this approach isn't feasible, <b>HARD BINDING&nbsp;</b><code>Function.prototype.bind</code> is the fix.		context_loss execution_context indirect_invocation invocation_types scope variable
"Identify and describe the ""insidious and well-known"" trap related to&nbsp;<code>Function</code>s invoked via normal function invocation within the scope of a <code>method</code> body."	"The trap is expecting the value of <code>this</code> in an executing method's body to propagate to functions that execute in the scope of the method body.<br><br>
Assuming we invoke the method via method invocation, the method will receive its execution context implicitly from JS and will be the object used to invoke the method.&nbsp;Thus, despite the context keyword <code>this</code><i> within the method body </i>referencing the method receiver upon method invocation, the <i>internal function's</i> execution context is still received implicitly from Javascript since it was invoked via normal function invocation.&nbsp; Thus, the internal function's execution context is the executing runtime environment's global object or undefined (in strict mode)."		execution_context explicit function_invocation global_object implicit method_invocation scope this
List the four forms of invocation in Javascript.	"<ol><li>function:&nbsp;<code>alert(""hi"")</code>&nbsp;</li><li>method:&nbsp;<code>console.log(""hi"")</code>;</li><li>constructor: <code>new String(""hi"")</code></li><li>indirect: <code>alert.call(undefined, ""hi"")</code>&nbsp;&nbsp;</li></ol>"		constructor_invocation function_invocation indirect_invocation invocation_types method_invocation
The execution context of a function is the eventual value of ____ within that function's body.	<code>this</code><br><br>(true of all functions, regardless of how they are invoked &amp; how they are defined)<br><br>IS THIS ACTUALLY TRUE WHEN WE CONSIDER strict mode code?		constructor_invocation execution_context invocation_types this
What type of function invocation is an IIFE?	"IIFEs are typically invoked via normal function invocation since the value between the first set of parentheses evaluates to a <code>Function</code> object which is then invoked using the <code>()&nbsp;</code>syntax.&nbsp; However, if we are using either <code>call </code>or <code>apply</code> as the function's&nbsp;<i>""agent of invocation"",</i> then it would also be true to say that IIFEs can execute via indirect invocation."		execution_context invocation_types
What determines what the global object is?	The value of the global object is determined by which runtime environment our code is executing in (eg. Node.js or Browser)<br><br>It's also worth noting that, while strict mode <i>does</i> <u>influence</u> the value of <code>this,</code>&nbsp;that is not the same thing as saying that strict mode <i>changes</i>&nbsp;or replaces the global object.  It still exists and is available.  The difference is that in scenarios which involve implicit <i>function</i> execution context and thus the function's context object being set to the global object, the value of <code>this</code> inside that function's body is undefined.		runtime_environment strict_mode_code
How will strict mode impact the execution context of a&nbsp;function invocation?&nbsp; You can assume that the function in question was defined using either the function declaration syntax or that a local variable was declared and initialized to the value of a reference which points to an anonymous function expression or it was an anonymous function returned from another function.	This answer hinges on whether strict mode is enabled in the scope where our function was defined, and depending on how and where (which scope) it is ultimately invoked.&nbsp;&nbsp;	"<img src=""Screenshot 2023-10-01 at 11.11.49 AM.jpg"">"	execution_context function_invocation strict_mode_code
"True or False:&nbsp;<i>""The value of&nbsp;<code>this</code> in an inner function depends only on invocation, not on the value of <code>this</code> in an outer function""</i>"	"True*&nbsp;<br><br>(Assuming the function is invoked via function invocation and isn't defined using the arrow function syntax) The value of <code>this</code> in an outer function <b>DOES NOT</b> propagate to function scopes enclosed by that outer function.<br><br>Helpful comparison: The behavior of the <code>""use strict""</code> directive <b>DOES</b> propogate; internal functions ""inherit"" the directive set in an outer function scope.<br><br>*caveat:<br><br> scenario: inner function is an arrow function.&nbsp; AF's execution context is determined/set based on the value of <code>this </code> in enclosing scope of the arrow function's definition; the execution context of that enclosing scope becomes the arrow function's execution context"		arrow_function function_definition invocation_types scope this
True or False: The object which owns a method is always that method's execution context when the method is invoked using <i>property accessor</i>&nbsp;+&nbsp;<code>()</code> syntax (eg. method invocation, implicit method execution context)	"False.&nbsp;&nbsp;<br><br>An object which is downstream from the method's containing object can be used to invoke that method via prototypal inheritance. Thus, that method's execution context is the downstream object despite being ""owned"" by the upstream containing object.<br><br>Another case is the edge case of a method defined using the arrow function syntax.  Despite being invoked via method invocation and having received its execution context implicitly from JS, that method's execution context will NOT be that method's containing object but instead whatever the value of <code>this</code>&nbsp;is in the enclosing scope to that object literal since Arrow Functions inherit their execution context based on the value of <code>this</code> in the enclosing scope of their definition and since objects don't ""create"" new scopes, that scope is whatever is external to the object literal."		delegation execution_context implicit inheritance prototype_chain this
Under what conditions can we omit the ending &nbsp;<code>()</code> in a constructor invocation?	The parens can be omitted if the function being invoked as a constructor is being called without any arguments being passed into the function.		constructor_invocation constructors invocation_types
What is the execution context of a function invoked as a <code>Constructor</code>?	The execution context of a function invoked as a <code>Constructor</code> is the value of <code>this</code>.  The object which <code>this</code> references is constructed by Javascript using the value of the constructor's <code>prototype</code> property as the created object's <b>object prototype</b>.  So, assuming that the function doesn't&nbsp;<i>explicitly</i> return an object different from the value of <code>this</code>&nbsp;and instead relies on the value of <code>this </code>being returned <i>implicitly</i>, <code>Constructor</code>'s context object is also its return value.		execution_context implicit_return new this
"Why do we say that functions are ""dynamically bound""?"	"Functions are said to be ""dynamically bound"" since their execution context is set/bound at time of invocation;&nbsp;<i>how</i>&nbsp;(and where) a function is invoked determines the execution context of that function.&nbsp; And since functions are first class, it follows that the same function can naturally can be passed around, returned, and invoked in different places and in different ways throughout the life of the program,  thus we say functions are dynamically bound."		execution_context first_class_citizen invocation_types
What special method is responsible for initializing the execution context of a function invoked as a constructor? (Pre-ES6)<br><br>What object <b>owns</b> this special method?<br><br> What is that object's relationship to the <code>Constructor</code>?<br><br>To <code>Constructor</code>'s execution context?	The <code>constructor</code> method defined on&nbsp;<code>{ Constructor.prototype }</code>.<br><br><code>{ Constructor.prototype }</code> is the [[Prototype]] of all of <code>Constructor</code>'s instances (it's also accurate to say that <code>{ Constructor.prototype }</code> is the prototype of <code>Constructor</code>'s execution context.<br><br>It's also worth noting that the <i>value</i> of <code>Constructor.prototype.constructor</code> is a reference to <code><b>Constructor</b></code> itself.		constructor_invocation constructors execution_context function_prototype this
S<i>ome</i>&nbsp;<code>Function</code>s can be invoked as functions and create instances as if they were invoked as constructors (eg.<code>new RegExp() vs RegExp()).</code>&nbsp; What potential issues can this cause?	"part2: some <code>Function</code>s intended to be invoked as constructors are flexible with their specific implementation and the nature of their invocation.&nbsp; However, issues often arise when this pattern is applied since some constructors may omit the logic to initialize the object when <code>new</code> is omitted.<br><br>such functions are called ""scope-safe""."		constructors scope_safe
"Why does <code>typeof</code> <code>function</code> return <code>""function""</code> but&nbsp;<code>typeof</code> <code>array</code> return <code>""object""</code>?"	Basically, the specification defines different behavior for the <code>typeof</code> operator when its operand implements <code>call/apply/bind</code>.&nbsp; It's true that functions are themselves objects and as such we can add arbitrary properties to them like normal objects.<br><br>re: arrays. they're really just objects.		constructors inheritance
Describe how&nbsp;<i>indirect invocation&nbsp;</i>facilitates the functionality of ES6's&nbsp;<code>class super()</code> behavior.	<code>class super()</code> lets a class constructor call an upstream constructor (a parent or grandparent class ...) and delegate. <br><br>*caveat: <code>super</code> works with non-constructor methods so this isn't really true but is the normative case<br><br> In pre-ES6 parlance, we can invoke <code>call || apply</code> upon the desired parent Constructor and pass the currently-executing Constructor's execution context (<code>this</code>). Indirect invocation is the mechanism for explicit function/method execution are related concepts!		class delegation indirect_invocation super
Explain the relationship between the concepts: indirect invocation and explicit function execution context.&nbsp;&nbsp;	A normal function invocation executes with the default execution context of <code>window || global || undefined</code> therefore it can be asserted that, by default, functions rely on the Javascript engine to supply their execution context and thus have implicit function execution context (implicit: supplied by JS, explicit: supplied by me).<br><br>With <i>indirect invocation</i>, the developer supplies the function with its context by specifying that context in the first argument passed to either <code>call || apply</code>. These are related concepts that are challenging to explain in isolation without first understanding them in relation to one another.		execution_context explicit invocation_types this
Which of Javascript's 4 invocations types can a <i>bound function</i> be invoked via ___(type of invocation)___?	Technically, <code>bind</code> supports <i>all 4 of the types</i> of invocation in JS.  Since a bound function is simply a <code>Function</code> object with a pre-configured context, it can be invoked via any of the invocation types. And, since a bound function's context is set permanently, we won't observe the differing behaviors expected of <code>this</code> across 3 of the invocation types (function, method, indirect). This is not the case when we invoke a bound function via constructor invocation.  Constructor invocation of a bound function overrides that function's pre-configured context and sets it instead to the instance that constructor begets (assuming no other object is explicitly returned by the constructor!).		execution_context indirect_invocation invocation_types
How can we invoke a bound <code>Function</code> with a different context link from the one specified when we created a new function via&nbsp;<code>myFn.bind(ctx)</code>? 	The only way to subvert the <b>permanent context link </b>of a bound function is through&nbsp;<b>Constructor Invocation.</b>&nbsp;		constructor_invocation execution_context explicit
What is the execution context of an arrow function?	The execution context of an arrow function is the current value of&nbsp;<code>this</code>&nbsp;within the immediate enclosing lexical scope where the arrow function was&nbsp;<b>defined. </b>The execution context of the arrow function depends on the program's execution&nbsp;<b>state</b>&nbsp;where the arrow function was originally defined<b>.</b>		arrow_function execution_context lexical_environment scope
"The author of the ""gentle explanation of this"" article talks about&nbsp;<code>function</code>s ""creating"" their own contexts.  What do they mean by this and what are the possible issues with that mental model?"	"It would be more accurate to say that regular functions (eg. non-arrow, non-constructor, non-indirectly-invoked ones) have their context configured implicitly (by the Javascript engine) when they are invoked. However, functions ""creating their own context""&nbsp;<i>is helpful as a mental model </i>as it communicates that function execution context is dynamic in nature (eg. JS sets a function's context; it is made clear in this phrasing that an <b>entity</b>&nbsp;<i>other than</i> the developer is&nbsp;<i>doing the context configuration).&nbsp; </i>Beyond this, I'm not sure there's much utility in using the phrase. I think this phrasing becomes problematic since people often also speak of (non arrow) functions ""creating"" or ""defining"" their own function scope, since a) scope exists prior to execution and b) the ""agent"" of creation of both the scope and the execution context for a function is the Javascript runtime itself. It seems to be a simple matter of perspective; both are valid but I prefer to think of the agent in the scenario being JS itself ""acting"" upon the function object being invoked as opposed to the function object having agency.<br><br>That being said, I am a fan of the ""context transparency"" phrase the author employs when describing how arrow functions receive their EC.&nbsp; re: functions 'creating/defining' their own scopes, I prefer the phrase, ""xFunction's invocation&nbsp;<i>introduces&nbsp;</i>a new local scope..."""		execution_context mental_model scope
How do we subvert the context of an executing arrow function?	"It's impossible.&nbsp; Upon definition, the execution context of an arrow function is henceforth, forever and always, throughout the known universe, set.<br><br>This is explained by the simple fact that arrow functions don't get their own <code>this</code> context binding but instead ""inherit"" the context where they are originally defined at the time of definition.  It can be useful to think of arrow functions as being&nbsp;<i>embedded&nbsp;</i>inside the lexical scope where they are defined.&nbsp; This is not to say that they don't create their own scope, they do."		arrow_function execution_context function_definition lexical_environment
What happens when we invoke an arrow function via constructor invocation?	If we try to invoke an arrow function as a constructor, JS with throw a&nbsp; <code>TypeError: {arrow} is not a constructor</code>.  This is true with/without the <code>'use strict'</code> directive.		arrow_function constructor_invocation error new
Why is it wise to avoid defining a method using the ES6 arrow function syntax?	We should <b>avoid</b> defining methods using the arrow function syntax since the execution context of an arrow function is determined by the <i>current</i> value of <code>this</code>&nbsp;within the enclosing lexical scope where that arrow function was defined originally. Additionally, unlike alternative <code>function</code> definition syntax, we cannot provide an explicit context object using <code>call apply bind </code> were we to extract that function from its original container.&nbsp;<br><br>Suppose we are applying the <code>Constructor</code> object creation pattern and add functionality: <code>OurConstructor.prototype.newBehavior = () =&gt;  this</code> and then later attempt to invoke the&nbsp;<code>newBehavior</code>&nbsp;method upon an&nbsp;<code>instanceof&nbsp;</code> <code>OurConstructor</code>, the value of&nbsp;<code>this</code> will remain whatever <code>this</code> was when/where we added <code>newBehavior</code> to the object:&nbsp;<code>MyConstructor.prototype</code>.&nbsp;<br><br>Hence, we <b>cannot reliably </b>remove the <code>Function</code> from its containing object nor can we perform other <b>useful</b> <code>Constructor </code>actions with that <code>Function</code> object, which limits our code's extensiblility and maintainability.  		arrow_function best_practices function_definition function_type lexical_environment this
Given the code:&nbsp;<code>function fn() { return this }</code>, what is&nbsp;<code>this</code>?<br><br>What rule does this scenario demonstrate re: execution context?	Without knowing a) the code's runtime environment or b) how&nbsp;<code>fn</code> is ultimately invoked, we cannot determine the value of <code>this</code>.&nbsp;&nbsp;<br><br>Basically, that the execution context of a regular function is based upon <i>how</i> and <i>where</i> that function is being invoked.		execution_context function_definition invocation_types runtime_environment this
Given the following:&nbsp;<code>let arrow = () =&gt; this</code> what is the context of the function?<br><br>What rule does this scenario demonstrate re: execution context?	"Without more information re: a) the value of <code>this</code> within the enclosing scope where&nbsp;<code>arrow</code>&nbsp;was defined and b) the execution state of that definition's enclosing lexical environment, we cannot know <code>arrows</code>'s execution context.<br><br>Despite having their execution context determined by factors: a. and b., we still cannot determine an arrow function's context absent info about that context and code execution itself. All we can be sure of is that the arrow function will inherit its execution context from the enclosing scope of its definition. (this is kind of a duh-umb statement as it isn't so much a ""rule"" as just common sense)"		execution_context lexical_environment
What's the difference between the below snippets?<br><code>containingObject.methodName</code><br><code>containingObject.methodName()</code>	*answer assumes that the value of <code>containingObject.methodName</code> is a reference to some function object. <br><br>The first demonstrates the use of the property accessor dot syntax and presumably returns the&nbsp;<code>Function</code> object referenced by <code>methodName</code>.<br><br>The second demonstrates method invocation syntax.		invocation_types lookup method_invocation property
Scenario: suppose we define a function&nbsp;<code>foo</code>&nbsp;using function declaration that we promptly invoke via <i>function invocation</i>. Based on how <code>foo</code> was invoked, Javascript sets <code>foo</code>'s execution context to the global object <code>window</code>. However, if we attempt to reference <code>window</code> and invoke <code>foo</code> via <i>method invocation: </i><code>window.foo()</code>, <code>undefined</code> is returned which makes sense since <code>window</code> doesn't have the property <code>foo</code>. However, doing this: <code>window.foo</code> returns the <code>foo</code> function object. <br><br>What conclusions can be drawn from this behavior and what does this mean for how we talk should talk about (implicit) execution context?<br><br>(This question assumes non-strict JS in-browser)		"<img src=""Screenshot 2023-10-03 at 9.19.12 PM.jpg"">"	function_definition function_invocation global_object invocation_types
Since&nbsp;<code>Function</code>s are really just <code>objects</code>, do they get stored on the heap?&nbsp; If true, how does this inform how we talk about variables and references?	Yes. <code>Functions</code> are stored on the heap.  Thus, a variable or object property holds a <i>reference</i> to where a <code>Function</code> is stored in memory.		garbage_collection memory variable
If, within the body of a method, we want another function to have access to the value of&nbsp;<code>this</code> in the method body but for some reason we cannot use an indirect invocation approach when invoking or returning the internal function, what alternative context-propogating approaches are available to us?	As far as I am aware, we have two options.&nbsp; One approach would be to declare a local variable outside the internal function but prior to its invocation/passing and set the value of that variable to the value of <code>this&nbsp;</code> within the method body. Then, we could simply access it like any other normal local variable that's in the lexical scope of a function definition.<br><br>Another approach might be to define the internal function using the arrow function syntax.  This works since the execution context of an arrow function is determined by the current value of <code>this</code> wherever the arrow function was <b>originally defined</b>.  In a sense, the described approach allows <code>this</code> to propagate to the body of (arrow) functions which are defined inside a method.		arrow_function common_misconception execution_context function_definition implicit invocation_types method_invocation
"True or False: ""Method invocations rely on implicit execution context that resolves to the object that holds the method."""	"Disregarding prototypal inheritance and assuming the method in question didn't at some point earlier get hard-bound to some explicit context and then placed in its current containing object, this statement is accurate. However, as soon as there is any sort of prototypal inheritance involved, the answer quickly falls apart.<br><br>Suppose we have two constructors: <code>A</code> and <code>B</code>, where <code>B</code> <i>extends</i> <code>A</code> and <code>A</code>'s function prototype has the property: <code>myMethod</code> which holds a reference to a function object.  An instance of <code>B</code> can be used to invoke <code>myMethod</code> through delegation since the <i>object prototype</i><b> </b>of <code>B</code>&nbsp;instances will directly inherit from <code>B</code>'s function prototype via prototypal inheritance.<br><br>Thus we cannot say with certainty that a method invoked via method invocation receives its context from the object where that method is defined.&nbsp; Only that the method receiver (also: ""calling object"") has access to a method which is defined on an upstream object."		delegation execution_context implicit inheritance method_invocation prototype_chain this
Name two things that are true of all <code>function</code>s in Javascript, regardless of their syntax?	<div>All functions, regardless of syntax, obey the same lexical scoping rules:</div><ul><li>have access to any variables defined in the scope they introduce and</li><li>can access any variables that were in scope based on the context where the function was&nbsp;<b>defined&nbsp;</b>(via closure and lexical scoping rules)</li></ul>		closure function_type lexical_scoping_rules
"Does the scope created when we define a function ""exist"" prior to invocation of the function?"	"Yes!&nbsp; Scopes ""exist"" absent execution of code/function."		lexical_environment lexical_scoping_rules scope
re: JS' variable lookup, what's important to remember about lexical scoping?	"How code is written determines the path JS takes as it navigates scope hierarchies.&nbsp; The ""visibility"" of a variable is dictated by source code since how our code is written establishes various nested local variable scopes (introduced by blocks and functions).<br><br>Remember that scope exists absent execution so to say that function or block ""creates"" a new local scope belies a weak mental model. It's better to say that a function or block&nbsp;<i>introduces&nbsp;</i>a scope that had previously been dormant (not sure about this term but for now seems to communicate the existing-but-not-yet-entered quality of an uninvoked function's scope)."		lexical_scoping_rules lookup scope variable
How can we determine if a function is a <i>Higher Order Function</i>?	If a function expects to receive a function object as one of its argument or upon invocation it is expected to return a function object, it's a H.O.F.		first_class_citizen higher_order_function
What's the relationship between these two concepts:&nbsp;<i>Higher Order Functions</i> and <i>First Class Functions</i>?	Since functions in JS are&nbsp;<i>first class citizens</i>, they can be passed to functions, returned from functions, or have their references held by variables &amp; properties.  The concept of H.O.F.s is facilitated through JS' support of the second concept.		first_class_citizen higher_order_function
What do we call the automatic process of memory deallocation?	Garbage Collection		garbage_collection memory
What are some of the inherent shortcomings of languages that don't provide garbage collection?	"Languages that don't have G.C. typically force the developer to claim and release memory for every piece of data their program requires.&nbsp; This involves&nbsp;<b>manual memory management; </b>which involves<b>&nbsp;</b>allocating and<b>&nbsp;</b>deallocating memory for each piece of data your program requires.&nbsp; The general process is: claim -&gt; test -&gt; release.&nbsp; The obvious shortcoming of this approach to memory management is that, since it's human-reliant, it is inherently error-prone and can lead to perhaps messy, and assuredly less succinct code.&nbsp; An example are ""memory leaks""."		garbage_collection
True or False: primitive values don't get involved in garbage collection when they are stored on the stack.	True.*&nbsp; Since primitive values are stored on the Stack and since the Stack doesn't participate in G.C., primitives don't get GC'ed. <br><br>* there's a few caveats here since, while Strings behave like other primitives which <b>invariably</b> (?) are stored on the Stack, the memory requirements for strings  can exceed the maximum fixed size required of values stored on the Stack. Basically, the actual location in memory (stack vs heap) where&nbsp;<b>primitives</b> like Strings and BigInts is an <i>implementation detail</i>.  As far as we the developer are concerned, all primitives are stored on the stack and thus they do not get GC'ed.		garbage_collection memory primitives
Can we as a programmer manually trigger garbage collection?	Not in modern implementations of JS.		garbage_collection
What is a common misconception about garbage collection?	"That GC ""happens"" when a variable which references an object goes out of scope.<br><br>This would only be true if it were the <i>only</i> live reference to that object and was never again available during the course of the code's execution."		common_misconception garbage_collection lexical_environment scope
What is a meaningful difference between early and modern implementations of Garage Collection in Javascript?	"The algorithm by which GC is implemented.&nbsp; Early JS used <u>a naive reference counting</u> algo whereas modern JS engines uses optimized <u>mark and sweep </u>algos.&nbsp;&nbsp;<br><br>One apparent shortcoming of RCA that is addressed by M&amp;S is the ""reference cycle problem"", or having objects that hold references to one another and thus creating a situation where data can never be released during the execution of a script.  A downside of mark and sweep is fragmented or <i>non-contigious</i> memory chunks which limit a system's ability to allocate large chunks of memory.  "		garbage_collection
Describe the impact that closures have upon the rules which govern garbage collection in Javascript as they pertain to variables assigned to primitives and objects.	"This is a bit of a trick question.&nbsp; As we know, the ""operational"" variables that are part of a function's closure ""endure"" beyond the ""life"" of the code wherein they were originally declared and initialized.&nbsp;<br><br>Since the stack doesn't participate in GC, the variables in the function's closure which are assigned to primitive values are never eligible for GC and thus we can say that the closures don't change how GC works for primitives. It's just (GC) business as usual.<br><br>The same cannot be said for those variables in the function's closure which hold references to objects since objects are stored on the heap which <b>does </b>participate in GC. So, if an object-referencing-variable is part of a function's closure, and that function persists, then the referenced object won't be eligible for GC."		closure dereferencing garbage_collection higher_order_function memory reassignment
Are Functions objects?	Yes.&nbsp; While we cannot change what is inside a function's body (the code part), we <b>can</b> add and remove properties to a function object, which is similar behavior to how we interact with other common objects.&nbsp; To be clear, an object's mutability is&nbsp;<b>not </b>the feature which sets it apart from primitives data types such numbers, undefined, strings, etc. (since there are such things as immutable objects (null?)); all primitives in JS&nbsp;just <i>happen&nbsp;</i>to be immutable.<br><br>irregularities: <code>typeof null</code>, <code>typeof someFn</code> -&gt; 'object', 'function'.		mutability primitives
Suppose a global variable holds a reference to an object.&nbsp; As an object assigned to a global variable, will that object ever be eligible for GC <i>prior to the program exiting?</i>	"This answer depends on how the global variable was declared.&nbsp; If it was declared with&nbsp;<code>var</code> or <code>let</code>, then YES, the global variable could be reassigned, meaning that the object could be marked as eligible for GC should that global variable be reassigned anywhere throughout the program's execution.<br><br>

However, if a global variable was declared with <code>const</code>, then there would exist an unbreakable connection between that variable's value (a reference) and the location in memory where the object exists. This would imply that NO, such an object would only ever be GC'ed upon the program's completion."		garbage_collection global_object reassignment scope
Re: the various stages of memory management (claim/test/copy/use/release), what stages are associated with GC?	"GC is solely associated with the ""release"" stage where JS frees-up memory.&nbsp; The other stages (claim/test/copy) are all performed by JS so the only stage the developer is concerned with is the ""use"" portion of the process.&nbsp; Though, the GC process is likely non-linear in nature.<br><br>I think a useful mental model is to think of the useage and release stages as happening simultaneously during the period of time when some code is executing.&nbsp; It wouldn't make sense for GC to only happen upon the exiting of some program."		garbage_collection memory
What is the golden rule of JS' garbage collection process?	So long as an object remains accessible, JS cannot and will not GC that object.		garbage_collection persistence
What function-specific concept facilitates partial function application?	Closure. <br><br>Since <code>generator</code>'s parameters are 1) present in the enclosing scope of <code>applicator</code>'s definition and 2) referenced in <code>applicator</code>'s body, the closure created by <code>applicator</code>'s <b>definition</b> has a reference to that parameter and as a result can use the eventual value of that parameter later on after <code>generator</code> has returned.<br><br>the concept of closure grants the developer the ability to define private data (or behavior) that will persist for the lifetime of the function whose closure holds references to that data (or behavior)		closure partial_function_application private_data
True or False: a named function defined inside an IIFE is accessible in the global scope.	"False.&nbsp; Despite being named, it isn't visible outside the parens of the IIFE.&nbsp;&nbsp;<br><br>The parens are the ""expression"" part of IIF<u>E</u>, thus by placing a function object inside, it becomes an expression (as opposed to a function defined via function declaration)"		immediately_invoked_function_expression lookup scope variable
What is (perhaps) unexpected about the keyword <code>this</code> within an object literal?	<code>this</code>' value depends on 1) if it is inside/outside a <code>function</code>&nbsp;(used inside a method body which is itself a property) and 2) if inside a function, depends upon <i>how</i> that enclosing function was defined and&nbsp;<b>invoked.<br></b><br>Since non-function objects don't create scope on their own, the value of&nbsp;<code>this</code> used in an object literal to say, assign one of that object's properties a value, will be whatever the value of <code>this</code> is in the enclosing lexical scope where the object literal is defined and initialized (which is either the global scope or a local scope introduced by a function).  		lexical_environment object_literal this
What type of function syntax might we choose if we want to pass a callback function with an explicit function execution context?	Either a normal function declaration that we&nbsp;<code>bind</code>&nbsp;or an anonymous function expression + <code>bind</code>.&nbsp; This allows us to avoid any unpredictable behavior re: execution context when working with higher order functions and passing around first class citizens.<br><br>Re: arrow functions.<br><br>If we rely on an arrow function which use this (even if they're defined INSIDE the parens of something like&nbsp;<code>forEach( ____ )</code> and we utilize forEach's <code>thisArg)</code>, the arrow function's context will <b>still</b> be whatever the value of this is in the enclosing lexical environment.	"<img src=""Screenshot 2023-10-06 at 1.21.12 PM.jpg"">"	arrow_function first_class_citizen function_definition higher_order_function
What is the value of <code>this</code> inside a method defined on an object which uses the arrow function syntax?&nbsp; Does placing the described code in an IIFE change our answer?	The value of <code>this</code> in the described scenario will be the current value of <code>this</code> in the enclosing lexical scope where the method is defined. <br><br>Not necessarily.&nbsp; If we are solely wrapping the code inside an IIFE and apply no other considerations (eg. strict mode) then the value of this won't be impacted and thus won't alter our answer.&nbsp;		arrow_function function_type immediately_invoked_function_expression
How might we create a closure with access to private data without using a higher order function?	We could create a function that returns an object which has a property with a <code>function</code> as its value.  This wouldn't be considered a higher order function since we're returning a non-function object which itself <i>contains</i> a function (the object's method) and not a function itself.&nbsp; The closure will still exist thus we will created a scenario where private data exists and is made accessible via the object's property's closure.		closure higher_order_function object_factories
Can you call an IIFE by name?	"The answer depends on&nbsp;<i>where&nbsp;</i>you intend to call it.&nbsp; If calling from within the IIFE, the answer is ""Yes"" (e.g. recursive IIFE).&nbsp; If calling from without, then the answer is ""No"". That goes against how IIFEs work since immediately upon definition, they are invoked.&nbsp; There is no way to reference the actual function object from outside the IIFE.&nbsp; That being said, there's nothing preventing an IIFE from having a name, however that name is local to the scope of the IIFE itself (eg. between the outermost parens)."		immediately_invoked_function_expression lookup scope variable
Do objects create their own scopes?	Unless we are talking about a <b>function</b> <b>object's</b> <i>body&nbsp;</i>introducing a new scope, then no, objects do not create their own scopes.&nbsp; Though, if an object has a property which is a method, then yes, it would be true that a new scope was introduced, but that isn't on account of the containing object, it is the function object referenced by one of the object's properties which introduced the new local scope.		scope
What does the&nbsp;<code>instanceof</code>&nbsp;operator assert?	"ex:&nbsp;<code>instance instanceof Constructor</code><br><br>In the above code, <code>instanceof</code> is testing to see if <code>Constructor</code>'s function prototype appears <i>anywhere</i> along <code>instance</code>'s prototypal inheritance chain. Essentially, <code>instanceof</code> poses the question, ""are any of the objects that <code>instance</code> inherits <b>from</b> and can delegate ""messages"" <b>to,</b>&nbsp;either the <b>same </b>object that <code>Constructor</code>'s <code>prototype</code> property points to or on the prototype chain?"".  If such an object&nbsp;<i>is</i>&nbsp;found, then <code>instanceof</code> will return true, othewise false.<br><br>All the below statements log&nbsp;<code>true</code>"	"<img src=""Screenshot 2023-10-03 at 10.07.09 PM.jpg"">"	__proto__vs_.prototype delegation inheritance object_prototype prototype_chain
What is&nbsp;<code>this</code>?	<code>this</code> is the context keyword (which behaves somewhat like a special variable in how we use and reference it) that dynamically references the current execution context.&nbsp; When outside the scope of a function body such as  used inside an object literal to initialize some property's value (and not inside a method on that object), <code>this</code> references the currently-executing code's context object.		execution_context this
Under what conditions can we omit the&nbsp;<code>new</code>&nbsp;operator when invoking a constructor?	"When the function being invoked which is intended to be a constructor is considered ""scope safe"". This means that the function was designed to operate the same via constructor invocation (eg. the format of&nbsp;<code>new</code> + <code>Constructor()</code>) or a different type of invocation."		constructor_invocation new scope_safe
What's a meaningful difference between the OLOO and factory function object creation patterns wrt our stack problem?	"<ul>
<li>Factory Function: stack data was private (good), no ""type"" info for instance (bad), behaviors are defined on an instance (bad)</li>
  <li></li>
</ul>"		object_factories OLOO
What will happen to a constructor's function prototype when we manually assign the constructor's prototype prop to point at a new object?	Assuming that there are no other references to the constructor's original function prototype, it will be marked as eligible for GC.		constructors function_prototype garbage_collection
What actually happens when we use:&nbsp;<code>a instanceof A</code>?	"JS looks to see if either <code>A.prototype</code> or an upstream object is the <i>parent</i>&nbsp;of&nbsp;<code>a</code> (eg. <code>a</code>'s <code>[[Prototype]]</code>). <br><br> <code>instanceof</code>'s behavior is somewhat obscured as <code>A</code> is the <i>constructor</i> function used by <code>a</code>'s object prototype: <code>A.prototype</code> itself which can lead to confusion when we are applying the pseudo-classical model since there what makes up the <code>A</code> ""class"" involves 2 distinct entities (a constructor function and its function prototype).<br><br>Thus, it's important to know what is actually going on under the hood with JS' implementation of ""classical"" inheritance."		__proto__vs_.prototype constructors function_prototype inheritance object_prototype pseudo-classical
What are two disadvantages to using factory functions?	1. redundant code<br>2. limited in that we cannot know if an object was created via the FF model or some other non-constructor object creation pattern.		object_creation_pattern object_factories
What is the value of <code>[[Prototype]]</code> for an object created without a specified prototype?	<code>Object.prototype</code> is the top-level, default prototype for all objects.&nbsp; However, the answer depends on the nature of that object's creation. If using <code>Object.create()</code> and no value is passed to&nbsp;<code>Object.create()</code> then its [[Prototype]] is the default.  If we're talking about constructor invocation, then the [[Prototype]] is the <code>{ Constructor.prototype }</code>. <br><br>		global_object inheritance object_prototype
An instance of some&nbsp;<code>function</code> invoked as a constructor can be said to _____ to their constructor's ______.	"""delegate"", ""function prototype"".<br><br>instances of constructors <i>delegate</i> <b><u>to</u></b>  and <i>inherit</i> <b><u>from</u> </b>their ""object prototype"".<br><br>Note that the ""function prototype"" and ""object prototype"" are the <b>same object.&nbsp;&nbsp;</b>The difference in language comes down to the talked-about entities' relationship (ie. function vs instance)"		constructors delegation function_prototype object_prototype
What are some sources of persistent references?	closures, objects, arrays, etc.; basically any object entity that has properties or is a function that created a closure and have reference counts &gt; 0.<br><br>simply by existing, these entities persist variable references.		closure first_class_citizen
What is a scenario where the value of <code>this</code> inside an in-built JS higher order function such as: <code>Array.prototype.forEach</code> might be confusing?	For some reason, it took me a bit to realize that the two functions executing inside this code:&nbsp;<code>myArray.forEach(ourCallback);</code>.<br><br>both <code>forEach</code> and <code>ourCallback</code> had (potentially) differing execution contexts.  <code>forEach</code>'s execution context is received <i>implicitly</i> from the JS engine since the method is invoked via <b>method invocation</b> whereas the execution context of our callback depends on how <code>ourCallback</code> is invoked by <code>forEach</code> and where (and how!) <code>ourCallback</code> was defined.  I'm also uncertain of <i>how</i> <code>forEach</code> invokes the callback (eg. what invocation type does the method use?). <br><br>update: I think that by default, <code>forEach</code> invokes the callback using normal function invocation.  This makes sense. If we want to choose the context for our callback and make it different than&nbsp;the <code>thisArg</code> of <code>forEach</code>, we can define the function differently		execution_context function_type higher_order_function invocation_types this
What are four important behavioral differences between the ES6&nbsp;<code>class</code> syntax and the underlying constructor pattern?	<ol><li>the code inside a class definition runs in strict mode</li><li>unlike with the bare constructor pattern, a class' <code>prototype</code>&nbsp;property cannot be reassigned</li><li>if you try to invoke a class constructor without <code>new</code>, JS will throw a <code>TypeError</code></li><li>unlike a bare constructor function declaration, a class defined via class declaration is&nbsp;<b>NOT&nbsp;</b>hoisted.&nbsp; The <i>name</i> of the class is hoisted, but the value is not set until the declaration code is executed during the execution phase.&nbsp; This means that the class will experience the Temporal Dead Zone.</li></ol>		class definition_type error ES6 function_prototype hoisting
"What does it mean to be a ""first-class citizen"" in Javascript?"	any value that can be <i>passed</i>&nbsp;into<i>&nbsp;</i>a function,&nbsp;<i>returned&nbsp;</i>from a function, or&nbsp;<i>assigned&nbsp;</i>to a variable is a <b>first-class citizen</b>		class first_class_citizen higher_order_function variable
Since&nbsp;a <code>class</code> is really just a function that enforces being invoked as a constructor (with new), what can we do with a class definition either in the declaration or expression syntax?	we can pass that class around just like we would a function since it's a first-class citizen.		class definition_type first_class_citizen higher_order_function new
"True or false: ""Since functions are first-class objects, classes must also be first-class objects."""	True.&nbsp; classes are just functions and as such, first-class objects.		class constructors first_class_citizen
"True or false: ""the object&nbsp;referenced by a constructor's <code>prototype</code> property is an example of a static property of that function."""	True.		constructors function_prototype
What's an inherent limitation of the factory function object creation pattern?	Extensibility.&nbsp; the FF pattern is great in that in allows us to create private data and introduce an API through which to interact with that data via pre-fabricated behaviors.&nbsp; We can use FFs as object factories and achieve useful functionality as a result. This is all possible through closure.&nbsp; Unfortunately, it doesn't make much sense when we require our code to be extensible.&nbsp;&nbsp;<br><br>Sure we can add methods or fields to the object our FF returned but those changes are only on that object, not other objects that we created via our FF.		object_factories trade_off
"What's the relationship between the concepts: <b>""prototypal&nbsp;inheritance""&nbsp;</b>and <b>""delegation""?</b>"	"an object&nbsp;<i><u>delegates to</u>&nbsp;</i>an upstream object and&nbsp;<i><u>inherits from</u>&nbsp;</i>an upstream object.<br><br>Further commentary:<br><br>The terms' relationship is evident when we think about the path taken to resolve a property lookup.<br><br>the term ""delegation"" is from the ""point of view"" of an downstream object; that downstream object can invoke a method that it doesn't ""own"" by delegating to an upstream object.&nbsp; In this scenario, the instance-object ""delegates"" the method (""message') <b>to</b> an object upstream of it via the prototypal inheritance chain.&nbsp;<br><br>Mirroring this, ""prototypal inheritance"" facilitates behavior sharing by upstream objects to downstream objects.&nbsp; Downstream objects inherit access to data and behaviors from upstream objects."		delegation inheritance prototype_chain
What's an important distinction between using&nbsp;<code>call apply</code> vs. <code>super</code>?  This question assumes that the former's use is in service of implementing the pseudo-classical constructor pattern.  The alternative assumes that we're using the <code>class</code> syntax. 	We don't have to pass a context object when we use&nbsp;<code>super()</code>.  This is different from <code>call apply</code> since those methods are predicated on the passing of a context object.&nbsp;<br><br>Just a small observation about the difference.		class execution_context object_creation_pattern pseudo-classical
"When using the OLOO object creation pattern, what's important to remember about the&nbsp;<code>init</code> method versus a ""normal"" constructor function?"	<code>init</code> needs to explicitly return <code>this</code> since <code>init</code> is <b>not</b> invoked as a constructor and thus won't automatically return the created object.		constructors explicit_return implicit_return object_creation_pattern OLOO this
We know that arrow functions cannot be invoked as constructors and the reason&nbsp;<i>seems&nbsp;</i>to be that they don't have the static property&nbsp;<code>prototype</code>.  That being said, suppose we added a prototype property to our constructor and attempted to invoke it via constructor invocation, would this allow us to use our arrow function as a constructor?	The answer is no, but I'd like to figure out exactly why we cannot use arrow functions as constructors.&nbsp; There are obvious reasons why we shouldn't but I haven't found a definitive answer.		arrow_function constructor_invocation constructors function_prototype
True or False: The execution context of an arrow function changes based upon where it is invoked.	False.		arrow_function execution_context function_definition
What are three central behaviors or concepts that are enabled by closure?	<ol><li>dynamic data privatization</li><li>partial function application</li><li>callback functions</li></ol>
`

const splitByTab = notionData.split(`		`);

splitByTab.slice(10, 20).forEach(console.log);


